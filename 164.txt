- > Big O Notation No matter what i read or how many people explain it to me I still do n't quite get what on earth this is ! Explain like I'm five.<>Let 's try an intuitive , rather than mathematical explanation . Generalizations , sweeping statements and oversimplifications will be made : Imagine you want to alphabetize your baseball card collection . It should be easy to see that if you only have 3 cards , you can solve this problem a lot quicker than if you have 3000 of them . Now imagine you still have n't organized your collection and you want to check if you have Albert Pujols somewhere in your pile of cards . Again , if you only have 3 cards , you can find the answer to this problem quickly ; but if you have 3000 , it might take you all afternoon . A lot of problems , the interesting ones that mathematicians like to study , are like that - the bigger the set of things that you have to look at to solve a particular problem ( let 's call this the \" input \" to the problem ) , the longer it will take to solve . * * Big - O notation aims to give you an idea of how much longer it will take to solve a problem as the input gets bigger and bigger . * * Notice I did n't say \" how long \" it takes , but * how much longer it takes * for every extra element you add to the input . Big - O notation says \" as the input gets bigger , the time it takes to solve the problem will grow by * * no more * * than this factor here . \" Going back to the Pujols problem , the only way to solve it is to look at every card in the pile . Sure , we might get lucky and find the card we 're looking for in the first try , but in the worst - case scenario we 'll find it dead last or not find it at all ; we 'll just have to look at every card to be sure we 've got the right answer . If looking at one card takes 1 second , looking at three cards will take 3 seconds , but looking at three thousand cards will take 3000 seconds . So to solve the Pujols problem it will take some constant amount of time ( e.g. , 1 second ) for every element of the input ( e.g. , 3000 cards ) . Conventionally , we call the size of the input * n * , so the total amount of time to find Pujols in an unsorted pile of cards is * n\\*1sec * . Since the 1 second is constant , the only thing really affecting how much longer it takes to solve the problem as * n * gets larger , is * n * itself , so we say that the Pujols problem is * O(n ) * ( pronounced \" Big - O of * n * \" or alternatively \" Order * n * . \" ) Now let 's imagine I asked you to find the Pujols card * * after * * you alphabetized all 3000 cards in your collection . This is a much quicker problem to solve ! Just turn to the \" P \" section of your card binder and look at every card . If turning to the right page takes 5 seconds and every section in the binder holds at most 200 cards ( remember , looking at a card takes 1 second ) then the worst - case scenario for finding Pujols will take * 5sec + ( 200\\*1sec ) = * * * 205 seconds * * ( you can actually make this quicker , but I 'm not going to get into that . Google \" binary search \" ) . You could have 200 cards , or you could have 5000 cards and it would still take 205 seconds in the worst case , usually a lot quicker . So by alphabetizing and indexing ( computer scientists would call this \" hashing \" ) your collection , you essentially made the size of the input irrelevant , we can now solve the Pujols problem in constant worst - case time . In Big - O notation , we denote this * O(1 ) * , which is like saying \" adding elements to the input multiplies the time it takes to solve the problem by a factor of * 1 * \" - no time increase at all . Other problems can respond differently to increasing * n * , so you 'll see things like * O(log n ) , O(n log n ) , O(n^2 ) , O(2^n ) * and many other variations . The important thing to remember is that the function between the parenthesis gives you an upper limit to how fast the time to solve a problem grows as the size of the input grows . The time could always grow slower than what the Big - O notation says , but never faster .<>Sure! Big O notation is a way of talking about how long an algorithm takes to run. Imagine you have a recipe for baking cookies. The recipe might say \"Preheat the oven to 350 degrees and bake for 10-12 minutes.\" This tells you how long it takes to bake the cookies. Now imagine you have a computer program that does something similar, like sorting a list of numbers. We can use Big O notation to describe how long it takes for the program to finish running. Here's an example: let's say you have a list of 10 numbers, and it takes the program one second to sort them. If you have a list of 100 numbers, it might take the program two seconds to sort them. If you have a list of 1000 numbers, it might take the program four seconds to sort them. In this case, we would say that the program's running time is \"O(n),\" where \"n\" is the number of items in the list. This means that the program's running time grows linearly with the size of the input. So, to sum it up: Big O notation is a way of describing how long an algorithm takes to run, based on the size of the input. It helps us understand how well an algorithm scales as the input gets larger.<>reddit_eli5